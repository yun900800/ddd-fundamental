## 为什么存在wildcards?

1. 在java中,数组是存在协变的;而泛型是不存在协变的,所以为了解决泛型协变的问题;所以引入了通配符来解决
    协变的问题

2. 如果使用无界的协变,那么只能取出一个对象为Object的值,尽管有一定的作用,但是作用不大

3. 为了解决协变的赋值和取值的问题，所以引入了<? extends T> 和 <? super T>前者解决取值的问题,后者解决赋值的
    问题

4. 通配符的引入还能在方法中捕捉到具体的泛型参数类型,因此能够捕捉原始类型以及通配符类型和泛型类型

5. Wildcards类解释了原始类型,具体泛型类型和无界通配符和有界通配符类型的区别;本质上差别不大;具体的使用场景
    不一样;每种泛型类型都有它们的使用范围.(这个例子存在细微差别,理解起来不是那么容易，适合早晨进行学习)
    同时练习29也是一个值得慢慢咀嚼的例子

6. 原始类型的泛型需要使用包装类型,Java会自动进行拆箱和装箱;如果有性能问题,可以使用apache的库来解决

7. 自动拆箱装箱似乎不能适用于原始类型数组

8. 一个类在实现泛型参数接口的时候,尽管泛型参数不一样,但是不能实现两次; 带参数的泛型接口不能实现多次;而不带参数的
    却可以实现多次；真是一个有意思的话题

9. 强制类型转化有时候在泛型中也是必要的,需要掌握一些泛型的强制转型方法

10. 泛型方法不支持重载;所以不同的泛型参数的方法最好是用不同的方法名称

11. 基类实现了泛型接口以后,子类就不能再实现同样的泛型接口,就好比这个接口的泛型参数被劫持了一样
    继承的子类或者重写这个接口或者再次重新实现这个接口

12. 自包含类型的作用是在基类中可以在方法的参数和返回值中使用派生类的类型;这种作用和方法协变有些类似
    但是也有些区别;自包含的类可以被继承,如果类不是被自包含，那么这个类不能继承; 不包含泛型参数的类
    可以被继承. 自包含的参数也可以使用在方法中,这样可以限制方法参数的类型,这个参数一定是一个自包含的
    类

13. 不是自包含的类也能实现自包含的效果，唯一的区别是约束不是强制的; 同时参数协变与自包含类型的似乎区别不大;
    唯一有一点不同是父类可以作为模板来使用子类的类型;而方法参数协变做不到这一点

14. 在非泛型类型的代码中,方法的参数类型不会因为子类的不同而改变;而自包含类型只能使用子类作为参数;
    这里需要理解的是 原始类型代码;自包含泛型类型代码;非自包含泛型类型各自在方法参数中的区别,究竟是重载
    重写，还是只能选择特定的子类型; SelfBoundedType这个类显示了使用子类和父类共同完成一些任务;
    一般来说父类是共同任务,而子类是个性任务，因此这样的自包含代码能够更加有扩展性

